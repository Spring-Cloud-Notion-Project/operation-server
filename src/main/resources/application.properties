#spring.threads.virtual.enabled=true
spring.application.name=operation-server
spring.profiles.active=dev
server.port=8082
spring.autoconfigure.exclude=org.redisson.spring.starter.RedissonAutoConfigurationV2

# spring.config.import=optional:configserver:http://config-server:8888?fail-fast=true&max-attempts=10&max-interval=1500&multiplier=1.2&initial-interval=1100

spring.graphql.grapiql.enabled=true

#management.zipkin.tracing.endpoint=http://zipkin:9411/api/v2/spans
# Eureka Client
eureka.client.preferIpAddress=true
eureka.client.registerWithEureka=true
eureka.client.fetchRegistry=true
eureka.client.serviceUrl.defaultZone=http://discovery-server1:8761/eureka,http://discovery-server2:8762/eureka,http://discovery-server3:8763/eureka

# Management (Health, Endpoints, Tracing)
management.health.curcuitbreakers.enabled=true
management.endpoints.web.exposure.include=*
management.endpoint.health.enabled=true
management.endpoint.health.show-details=always
management.endpoint.health.show-components=always
management.tracing.sampling.probability=1.0

# Resilience4j CircuitBreaker
#resilience4j.circuitbreaker.configs.default.registerHealthIndicator=true

# AI Server CircuitBreaker
resilience4j.circuitbreaker.instances.ai-server.slidingWindowType=COUNT_BASED
resilience4j.circuitbreaker.instances.ai-server.slidingWindowSize=20
resilience4j.circuitbreaker.instances.ai-server.permittedNumberOfCallsInHalfOpenState=5
resilience4j.circuitbreaker.instances.ai-server.minimumNumberOfCalls=20
resilience4j.circuitbreaker.instances.ai-server.waitDurationInOpenState=20s
resilience4j.circuitbreaker.instances.ai-server.failureRateThreshold=50
resilience4j.circuitbreaker.instances.ai-server.eventConsumerBufferSize=10
resilience4j.circuitbreaker.instances.ai-server.registerHealthIndicator=true

# Validation Server CircuitBreaker
resilience4j.circuitbreaker.instances.validation-server.slidingWindowType=COUNT_BASED
resilience4j.circuitbreaker.instances.validation-server.slidingWindowSize=100
resilience4j.circuitbreaker.instances.validation-server.permittedNumberOfCallsInHalfOpenState=10
resilience4j.circuitbreaker.instances.validation-server.minimumNumberOfCalls=100
resilience4j.circuitbreaker.instances.validation-server.waitDurationInOpenState=60s
resilience4j.circuitbreaker.instances.validation-server.failureRateThreshold=50
resilience4j.circuitbreaker.instances.validation-server.eventConsumerBufferSize=10
resilience4j.circuitbreaker.instances.validation-server.registerHealthIndicator=true

# Resilience4j Bulkhead
resilience4j.bulkhead.instances.ai-server.maxWaitDuration=0ms
resilience4j.bulkhead.instances.ai-server.maxConcurrentCalls=10
resilience4j.bulkhead.instances.ai-server.registerHealthIndicator=true

resilience4j.bulkhead.instances.validation-server.maxWaitDuration=0ms
resilience4j.bulkhead.instances.validation-server.maxConcurrentCalls=25
resilience4j.bulkhead.instances.validation-server.registerHealthIndicator=true

# Resilience4j Retry
resilience4j.retry.instances.ai-server.maxAttempts=2
resilience4j.retry.instances.ai-server.waitDuration=500ms
resilience4j.retry.instances.ai-server.intervalFunction.type=exponential
resilience4j.retry.instances.ai-server.intervalFunction.exponential-backoff-multiplier=2.0
resilience4j.retry.instances.ai-server.intervalFunction.max-interval=5000
resilience4j.retry.instances.ai-server.retryExceptions=java.io.IOException,java.util.concurrent.TimeoutException
resilience4j.retry.instances.ai-server.registerHealthIndicator=true

resilience4j.retry.instances.validation-server.maxAttempts=3
resilience4j.retry.instances.validation-server.waitDuration=500ms
resilience4j.retry.instances.validation-server.intervalFunction.type=exponential
resilience4j.retry.instances.validation-server.intervalFunction.exponential-backoff-multiplier=2.0
resilience4j.retry.instances.validation-server.intervalFunction.max-interval=5000
resilience4j.retry.instances.validation-server.retryExceptions=java.io.IOException,java.util.concurrent.TimeoutException
resilience4j.retry.instances.validation-server.registerHealthIndicator=true

# Resilience4j RateLimiter
resilience4j.ratelimiter.instances.ai-server.limitForPeriod=10
resilience4j.ratelimiter.instances.ai-server.limitRefreshPeriod=500ms
resilience4j.ratelimiter.instances.ai-server.timeoutDuration=5s
resilience4j.ratelimiter.instances.ai-server.registerHealthIndicator=true

resilience4j.ratelimiter.instances.validation-server.limitForPeriod=20
resilience4j.ratelimiter.instances.validation-server.limitRefreshPeriod=500ms
resilience4j.ratelimiter.instances.validation-server.timeoutDuration=5s
resilience4j.ratelimiter.instances.validation-server.registerHealthIndicator=true


# REGISTRO DAS FUN합ES
spring.cloud.function.definition=reportEventProducer;documentProcessor;failureProcessor

# CONFIGURA합ES KAFKA
#spring.cloud.stream.kafka.binder.producer-properties.key.serializer=org.apache.kafka.common.serialization.StringSerializer
#spring.cloud.stream.kafka.binder.brokers=localhost:9092

# CONFIGURA플O DO RABBIT MQ
spring.rabbitmq.host=localhost
spring.rabbitmq.port=5672
spring.rabbitmq.username=guest
spring.rabbitmq.password=guest

# CONFIGURA플O DOS BINDINGS
spring.cloud.stream.bindings.reportEventProducer-out-0.destination=report.requests
spring.cloud.stream.bindings.reportEventProducer-out-0.content-type=application/json

spring.cloud.stream.bindings.documentProcessor-in-0.destination=report.document-created
spring.cloud.stream.bindings.documentProcessor-in-0.group=operation-server-processor

spring.cloud.stream.bindings.failureProcessor-in-0.destination=report.failed
spring.cloud.stream.bindings.failureProcessor-in-0.group=operation-failure-group

# CONFIGURA플O DO BANCO LOCAL
spring.datasource.url=jdbc:h2:mem:testdb
spring.datasource.driverClassName=org.h2.Driver
spring.datasource.username=sa
spring.datasource.password=password
spring.jpa.database-platform=org.hibernate.dialect.H2Dialect